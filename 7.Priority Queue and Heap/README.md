### 우선순위 큐란? 
#### 우선순위 큐도 큐와 동일하게 push,pop,top이라는 연산이 있다.
#### C++ STL<queue> 헤더에서 제공하는 컨테이너 
#### 우선순위 큐에서는 우선순위가 현재 우선순위 큐 안에서 우선순위가 가장 높은 데이터가 먼저 삭제가 된다.
#### 우선순위 큐도 큐처럼 리스트로 구현이 가능하지만, 보통은 힙(Heap) 이라는 자료구조로 구현이 된다.

### 힙(Heap) 이란?
#### 힙은 완전 이진 트리(Complete Binary Tree)이다.
#### 모든 노드에 저장된 값(우선순위)들은 자식노드의 것보다(우선순위가) 크거나 같다.
#### *직접 연결된 자식-부모 노드간의 크기만 비교하면 된다.*
### 힙(Heap)은 루트노드에 우선순위가 높은 데이터를 위치시키는 자료구조가 된다.
![image](https://user-images.githubusercontent.com/77561827/220017965-3ab63251-6594-40d2-9e31-81cefaffee86.png)

#### 최대 힙(Max Heap)은 완전 이진트리이면서, 루트 노드로 올라갈수록 저장된 값이 커지는 구조이다.

![image](https://user-images.githubusercontent.com/77561827/220018219-5b22598a-ee9e-4af9-8229-bcca601d79b2.png)

#### 최소 힙(Heap)은 완전 이진트리이면서, 루트 노드로 올라갈수록 값이 작아지는 구조이다.

### <b>최대 힙이던 최소 힙이던 루트 노드에는 우선순위가 높은 것이 자리잡게 된다.

## 최소 힙에 저장할 떄 
![image](https://user-images.githubusercontent.com/77561827/220253768-ae7f2d94-d384-4d7e-95a5-e683041cf1a5.png)

위와 같은 최소힙에 어떤 노드가 하나 들어오는 상황을 가정해보자.
<p>제일 먼저, 들어올 새 노드가 "우선순위가 낮다"는 가정을 하고 '맨 끝 위치'에 저장한다.</p>

#### 맨 끝 위치에 저장한다는 것도 완전이진트리를 만족해야 한다는 것이니 '7'의 left child로 들어가야한다.
#### 그리고 부모노드와 우선순위를 비교해서 위치를 바꿔나간다.
![image](https://user-images.githubusercontent.com/77561827/220256793-06d7f403-35cc-48c0-bcb3-e90d0d562c78.png)

<p>최대힙은 반대로 부모와 자식노드를 비교해서 자식이 더 크면 서로 자리바꿈하면 된다. </p>

## 최소 힙에서 삭제할 때
#### 우선순위 큐 에서 pop은 곧, <b>가장 우선순위가 높은 데이터를 빼낸다는 의미</b>
#### 우선순위 큐의 pop을 힙에 대입해본다면, 힙의 루트노드를 반환(삭제)하는 것과 같을 것이다.

### 힙에서 가장 우선순위가 높은 데이터는 루트노드인데, 이 루트 노드를 삭제하면서 힙의 구조를 그대로 유지하는 것이 관건이다. (이 힙의 구조를 유지하는 과정을 heapify 라고 한다.)
![image](https://user-images.githubusercontent.com/77561827/220259287-569c68e8-278e-4d59-a919-8cd5934c316c.png)
<p>계속 진행해 나가면서 최소 힙의 구조를 유지할때 까지 반복한다. </p>


### 선택정렬
#### 선택정렬은 첫번째 자료를 두번째 자료부터 마지막 자료까지 하나하나 비교하며 가장 작은 값을 맨 앞에 둔다.
#### 그렇게 2회차 3회차 끝까지 하게된다.

### 삽입정렬
#### 삽입정렬은 두번째 자료부터 시작하여 그 앞의(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.
#### 즉, 두번째 자료는 첫번째와, 세번째 자료는 첫번째 두번째 자료와 비교한후 자료가 삽입될 위치를 찾는다.
#### 처음 key 값은 두번째 자료부터 시작한다.


